"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Weth = exports.Erc1155 = exports.Erc721 = exports.Erc20 = void 0;
const contracts_1 = require("@ethersproject/contracts");
const Addresses = __importStar(require("./addresses"));
const utils_1 = require("../utils");
const Erc20_json_1 = __importDefault(require("./abis/Erc20.json"));
const Erc721_json_1 = __importDefault(require("./abis/Erc721.json"));
const Erc1155_json_1 = __importDefault(require("./abis/Erc1155.json"));
/**
 * The Erc20 interface provides partial functionality to interact with an ERC20 Ethereum smart contract.
 */
class Erc20 {
    constructor(provider, address) {
        this.contract = new contracts_1.Contract(address, Erc20_json_1.default, provider);
    }
    /**
     * Sets amount as the allowance of spender over the callerâ€™s tokens.
     * @param approver Abstracted Ethereum Account, usually as a JsonRpcSigner
     * @param spender Ethereum address of a contract allowed to spend the approver's tokens
     * @param amount Token amount to be allowed to spend
     * @returns The contract transaction
     */
    async approve(approver, spender, amount = utils_1.MaxUint256) {
        return this.contract.connect(approver).approve(spender, amount);
    }
    approveTransaction(approver, spender, amount = utils_1.MaxUint256) {
        const data = this.contract.interface.encodeFunctionData("approve", [
            spender,
            amount,
        ]);
        return {
            from: approver,
            to: this.contract.address,
            data,
        };
    }
    /**
     * @param owner The owner's Ethereum address
     * @returns The owner's token balance
     */
    async getBalance(owner) {
        return this.contract.balanceOf(owner);
    }
    /**
     * @param owner Ethereum address to be queried
     * @param spender Ethereum contract
     * @returns The remaining number of tokens that spender will be allowed to spend on behalf of owner through transferFrom.
     */
    async getAllowance(owner, spender) {
        return this.contract.allowance(owner, spender);
    }
}
exports.Erc20 = Erc20;
/**
 * The Erc721 interface provides partial functionality to interact with an ERC721 Ethereum smart contract.
 */
class Erc721 {
    constructor(provider, address) {
        this.contract = new contracts_1.Contract(address, Erc721_json_1.default, provider);
    }
    async isValid() {
        return this.contract.supportsInterface("0x80ac58cd");
    }
    /**
     * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.
     * @param approver Abstracted Ethereum Account as a JavaScript object, usually a JsonRpcSigner
     * @param operator The operator's Ethereum address
     * @returns The contract transaction
     */
    async approve(approver, operator) {
        return this.contract.connect(approver).setApprovalForAll(operator, true);
    }
    approveTransaction(approver, operator) {
        const data = this.contract.interface.encodeFunctionData("setApprovalForAll", [operator, true]);
        return {
            from: approver,
            to: this.contract.address,
            data,
        };
    }
    /**
     * Returns the owner of a token
     * @param tokenId The token ID number
     * @returns The token owner's Ethereum address
     */
    async getOwner(tokenId) {
        return this.contract.ownerOf(tokenId);
    }
    /**
     * Determine if the operator is allowed to manage all of the assets of owner or not
     * @param owner The owner's Ethereum address
     * @param operator The operator's Ethereum address
     * @returns Wether the operator is allowed to manage all of the assets of owner or not
     */
    async isApproved(owner, operator) {
        return this.contract.isApprovedForAll(owner, operator);
    }
}
exports.Erc721 = Erc721;
/**
 * The Erc1155 interface provides partial functionality to interact with an Erc1155 Ethereum smart contract.
 */
class Erc1155 {
    constructor(provider, address) {
        this.contract = new contracts_1.Contract(address, Erc1155_json_1.default, provider);
    }
    async isValid() {
        return this.contract.supportsInterface("0xd9b67a26");
    }
    /**
     * Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.
     * @param approver Abstracted Ethereum Account, usually as a JsonRpcSigner
     * @param operator The operator's Ethereum address
     * @returns The contract transaction
     */
    async approve(approver, operator) {
        return this.contract.connect(approver).setApprovalForAll(operator, true);
    }
    approveTransaction(approver, operator) {
        const data = this.contract.interface.encodeFunctionData("setApprovalForAll", [operator, true]);
        return {
            from: approver,
            to: this.contract.address,
            data,
        };
    }
    /**
     * @param owner The owner's Ethereum address
     * @param tokenId The token ID number
     * @returns The owner's token balance
     */
    async getBalance(owner, tokenId) {
        return this.contract.balanceOf(owner, tokenId);
    }
    /**
     * Determine if the operator is allowed to manage all of the assets of owner or not
     * @param owner The owner's Ethereum address
     * @param operator The operator's Ethereum address
     * @returns Wether the operator is allowed to manage all of the assets of owner or not
     */
    async isApproved(owner, operator) {
        return this.contract.isApprovedForAll(owner, operator);
    }
}
exports.Erc1155 = Erc1155;
/**
 * The Weth interface provides partial functionality to interact with the Wrapped ETH (WETH) Ethereum smart contract.
 */
class Weth extends Erc20 {
    constructor(provider, chainId) {
        super(provider, Addresses.Weth[chainId]);
    }
    /**
     * Deposit ETH in the WETH smart contract to get the equivalent amount of WETH
     * @param depositor Abstracted Ethereum account, usually as a JsonRpcSigner
     * @param amount ETH amount to be deposited in the WETH smart contract
     * @returns The contract transaction
     */
    async deposit(depositor, amount) {
        return this.contract.connect(depositor).deposit({ value: amount });
    }
    depositTransaction(depositor, amount) {
        const data = this.contract.interface.encodeFunctionData("deposit");
        return {
            from: depositor,
            to: this.contract.address,
            data,
            value: (0, utils_1.bn)(amount).toHexString(),
        };
    }
}
exports.Weth = Weth;
//# sourceMappingURL=helpers.js.map