"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Order = void 0;
const bytes_1 = require("@ethersproject/bytes");
const constants_1 = require("@ethersproject/constants");
const contracts_1 = require("@ethersproject/contracts");
const hash_1 = require("@ethersproject/hash");
const solidity_1 = require("@ethersproject/solidity");
const wallet_1 = require("@ethersproject/wallet");
const Addresses = __importStar(require("./addresses"));
const helpers_1 = require("./helpers");
const builders_1 = require("./builders");
const Types = __importStar(require("./types"));
const Common = __importStar(require("../common"));
const utils_1 = require("../utils");
const Exchange_json_1 = __importDefault(require("./abis/Exchange.json"));
/**
 * The Wyvern v2 order interface provides functionality to interact with Project Wyvern Ethereum Smart Contracts and read data from the blockchain about order's current state.
 */
class Order {
    /**
     *
     * @param chainId The chain ID for the Ethereum network to be used. For example, 1 for Ethereum Mainnet and 4 for Rinkeby Testnet.
     * @param params The order parameters obtained from an API or built locally.
     */
    constructor(chainId, params) {
        if (chainId !== 1 && chainId !== 4) {
            throw new Error("Unsupported chain id");
        }
        this.chainId = chainId;
        try {
            this.params = normalize(params);
        }
        catch {
            throw new Error("Invalid params");
        }
        // Detect kind
        if (!params.kind) {
            this.params.kind = this.detectKind();
        }
        // Perform light validations
        // Validate fees
        if (this.params.makerRelayerFee > 10000 ||
            this.params.takerRelayerFee > 10000) {
            throw new Error("Invalid fees");
        }
        // Validate side
        if (this.params.side !== Types.OrderSide.BUY &&
            this.params.side !== Types.OrderSide.SELL) {
            throw new Error("Invalid side");
        }
        // Validate sale kind
        if (this.params.saleKind !== Types.OrderSaleKind.FIXED_PRICE) {
            // Support for dutch auctions will come later
            throw new Error("Invalid sale kind");
        }
        // Validate call method
        if (this.params.howToCall !== Types.OrderHowToCall.CALL &&
            this.params.howToCall !== Types.OrderHowToCall.DELEGATE_CALL) {
            throw new Error("Invalid call method");
        }
        // Validate listing and expiration times
        if (this.params.expirationTime !== 0 &&
            this.params.listingTime >= this.params.expirationTime) {
            throw new Error("Invalid listing and/or expiration time");
        }
        // Validate exchange
        if (this.params.exchange !== Addresses.Exchange[this.chainId]) {
            throw new Error("Invalid exchange");
        }
    }
    /**
     *
     * @returns The order's keccak256 hash
     */
    hash() {
        return (0, solidity_1.keccak256)(RAW_ORDER_FIELDS, toRaw(this.params));
    }
    /**
     *
     * @returns The order's EIP191 prefix hash
     */
    prefixHash() {
        return (0, hash_1.hashMessage)((0, bytes_1.arrayify)(this.hash()));
    }
    /**
     * Sign the Wyvern v2 order
     * @param signer Abstracted Ethereum account, usually as a JsonRpcSigner
     */
    async sign(signer) {
        const signerChainId = await signer.getChainId();
        if (this.chainId !== signerChainId) {
            throw new Error("Wrong chain id");
        }
        const signerAddress = await signer.getAddress();
        if ((0, utils_1.lc)(this.params.maker) !== (0, utils_1.lc)(signerAddress)) {
            throw new Error("Wrong signer");
        }
        const { v, r, s } = await signer
            .signMessage((0, bytes_1.arrayify)(this.hash()))
            .then(bytes_1.splitSignature);
        this.params = {
            ...this.params,
            v,
            r,
            s,
        };
    }
    /**
     * Build a matching buy order for a sell order and vice versa
     * @param taker The taker's Ethereum address
     * @param data Any aditional arguments
     * @returns The matching Wyvern v2 order
     */
    buildMatching(taker, data) {
        return this.getBuilder().buildMatching(this, taker, ...(data || []));
    }
    /**
     * Check the validity of the order's signature
     */
    checkSignature() {
        var _a, _b;
        const signer = (0, wallet_1.verifyMessage)((0, bytes_1.arrayify)(this.hash()), {
            v: this.params.v,
            r: (_a = this.params.r) !== null && _a !== void 0 ? _a : "",
            s: (_b = this.params.s) !== null && _b !== void 0 ? _b : "",
        });
        if ((0, utils_1.lc)(this.params.maker) !== (0, utils_1.lc)(signer)) {
            throw new Error("Invalid signature");
        }
    }
    /**
     * Check the order's validity
     */
    checkValidity() {
        if (!this.getBuilder().isValid(this)) {
            throw new Error("Invalid order");
        }
    }
    /**
     * Check the order's fillability
     * @param provider A read-only abstraction to access the blockchain data
     */
    async checkFillability(provider) {
        var _a, _b;
        const chainId = await provider.getNetwork().then((n) => n.chainId);
        // Make sure the order is not cancelled or filled
        const hash = this.prefixHash();
        const exchange = new contracts_1.Contract(this.params.exchange, Exchange_json_1.default, provider);
        const filledOrCancelled = await exchange.cancelledOrFinalized(hash);
        if (filledOrCancelled) {
            throw new Error("filled-or-cancelled");
        }
        if (this.params.side === Types.OrderSide.BUY) {
            if (this.params.paymentToken === Common.Addresses.Eth[chainId]) {
                // Check balance
                const balance = await provider.getBalance(this.params.maker);
                if ((0, utils_1.bn)(balance).lt(this.params.basePrice)) {
                    throw new Error("no-balance");
                }
            }
            else {
                // Check that maker has enough balance to cover the payment
                // and the approval to the token transfer proxy is set
                const erc20 = new Common.Helpers.Erc20(provider, this.params.paymentToken);
                // Check balance
                const balance = await erc20.getBalance(this.params.maker);
                if ((0, utils_1.bn)(balance).lt(this.params.basePrice)) {
                    throw new Error("no-balance");
                }
                // Check allowance
                const allowance = await erc20.getAllowance(this.params.maker, Addresses.TokenTransferProxy[chainId]);
                if ((0, utils_1.bn)(allowance).lt(this.params.basePrice)) {
                    throw new Error("no-approval");
                }
            }
        }
        else {
            // Check that maker owns the token id put on sale and
            // the approval to the make'rs proxy is set
            const proxyRegistry = new helpers_1.ProxyRegistry(provider, chainId);
            const proxy = await proxyRegistry.getProxy(this.params.maker);
            if (!proxy) {
                throw new Error("no-proxy");
            }
            if ((_a = this.params.kind) === null || _a === void 0 ? void 0 : _a.startsWith("erc721")) {
                const erc721 = new Common.Helpers.Erc721(provider, this.params.target);
                // Sell orders can only be single token (at least for now), so
                // extracting the token id via the single token builder should
                // be enough
                const tokenId = new builders_1.Builders.Erc721.SingleToken(chainId).getTokenId(this);
                if (!tokenId) {
                    throw new Error("invalid");
                }
                // Check ownership
                const owner = await erc721.getOwner(tokenId);
                if ((0, utils_1.lc)(owner) !== (0, utils_1.lc)(this.params.maker)) {
                    throw new Error("no-balance");
                }
                // Check approval
                const isApproved = await erc721.isApproved(this.params.maker, proxy);
                if (!isApproved) {
                    throw new Error("no-approval");
                }
            }
            else if ((_b = this.params.kind) === null || _b === void 0 ? void 0 : _b.startsWith("erc1155")) {
                const erc1155 = new Common.Helpers.Erc1155(provider, this.params.target);
                // Sell orders can only be single token (at least for now), so
                // extracting the token id via the single token builder should
                // be enough
                const tokenId = new builders_1.Builders.Erc1155.SingleToken(chainId).getTokenId(this);
                if (!tokenId) {
                    throw new Error("invalid");
                }
                // Check balance
                const balance = await erc1155.getBalance(this.params.maker, tokenId);
                if ((0, utils_1.bn)(balance).lt(1)) {
                    throw new Error("no-balance");
                }
                // Check approval
                const isApproved = await erc1155.isApproved(this.params.maker, proxy);
                if (!isApproved) {
                    throw new Error("no-approval");
                }
            }
            else {
                throw new Error("invalid");
            }
        }
    }
    getBuilder() {
        switch (this.params.kind) {
            case "erc721-contract-wide": {
                return new builders_1.Builders.Erc721.ContractWide(this.chainId);
            }
            case "erc721-single-token": {
                return new builders_1.Builders.Erc721.SingleToken(this.chainId);
            }
            case "erc721-token-list": {
                return new builders_1.Builders.Erc721.TokenList(this.chainId);
            }
            case "erc721-token-range": {
                return new builders_1.Builders.Erc721.TokenRange(this.chainId);
            }
            case "erc1155-contract-wide": {
                return new builders_1.Builders.Erc1155.ContractWide(this.chainId);
            }
            case "erc1155-single-token": {
                return new builders_1.Builders.Erc1155.SingleToken(this.chainId);
            }
            case "erc1155-token-list": {
                return new builders_1.Builders.Erc1155.TokenList(this.chainId);
            }
            case "erc1155-token-range": {
                return new builders_1.Builders.Erc1155.TokenRange(this.chainId);
            }
            default: {
                throw new Error("Unknown order kind");
            }
        }
    }
    detectKind() {
        // erc721-contract-wide
        {
            const builder = new builders_1.Builders.Erc721.ContractWide(this.chainId);
            if (builder.isValid(this)) {
                return "erc721-contract-wide";
            }
        }
        // erc721-single-token
        {
            const builder = new builders_1.Builders.Erc721.SingleToken(this.chainId);
            if (builder.isValid(this)) {
                return "erc721-single-token";
            }
        }
        // erc721-token-list
        {
            const builder = new builders_1.Builders.Erc721.TokenList(this.chainId);
            if (builder.isValid(this)) {
                return "erc721-token-list";
            }
        }
        // erc721-token-range
        {
            const builder = new builders_1.Builders.Erc721.TokenRange(this.chainId);
            if (builder.isValid(this)) {
                return "erc721-token-range";
            }
        }
        // erc1155-contract-wide
        {
            const builder = new builders_1.Builders.Erc1155.ContractWide(this.chainId);
            if (builder.isValid(this)) {
                return "erc1155-contract-wide";
            }
        }
        // erc1155-single-token
        {
            const builder = new builders_1.Builders.Erc1155.SingleToken(this.chainId);
            if (builder.isValid(this)) {
                return "erc1155-single-token";
            }
        }
        // erc1155-token-list
        {
            const builder = new builders_1.Builders.Erc1155.TokenList(this.chainId);
            if (builder.isValid(this)) {
                return "erc1155-token-list";
            }
        }
        // erc1155-token-range
        {
            const builder = new builders_1.Builders.Erc1155.TokenRange(this.chainId);
            if (builder.isValid(this)) {
                return "erc1155-token-range";
            }
        }
        throw new Error("Could not detect order kind (order might have unsupported params/calldata)");
    }
}
exports.Order = Order;
const RAW_ORDER_FIELDS = [
    "address",
    "address",
    "address",
    "uint256",
    "uint256",
    "uint256",
    "uint256",
    "address",
    "uint8",
    "uint8",
    "uint8",
    "address",
    "uint8",
    "bytes",
    "bytes",
    "address",
    "bytes",
    "address",
    "uint256",
    "uint256",
    "uint256",
    "uint256",
    "uint256", // salt
];
const toRaw = (order) => [
    order.exchange,
    order.maker,
    order.taker,
    order.makerRelayerFee,
    order.takerRelayerFee,
    0,
    0,
    order.feeRecipient,
    1,
    order.side,
    order.saleKind,
    order.target,
    order.howToCall,
    order.calldata,
    order.replacementPattern,
    order.staticTarget,
    order.staticExtradata,
    order.paymentToken,
    order.basePrice,
    order.extra,
    order.listingTime,
    order.expirationTime,
    order.salt,
];
const normalize = (order) => {
    // Perform some normalization operations on the order:
    // - convert bignumbers to strings where needed
    // - convert strings to numbers where needed
    // - lowercase all strings
    var _a, _b, _c;
    return {
        kind: order.kind,
        exchange: (0, utils_1.lc)(order.exchange),
        maker: (0, utils_1.lc)(order.maker),
        taker: (0, utils_1.lc)(order.taker),
        makerRelayerFee: (0, utils_1.n)(order.makerRelayerFee),
        takerRelayerFee: (0, utils_1.n)(order.takerRelayerFee),
        feeRecipient: (0, utils_1.lc)(order.feeRecipient),
        side: (0, utils_1.n)(order.side),
        saleKind: (0, utils_1.n)(order.saleKind),
        target: (0, utils_1.lc)(order.target),
        howToCall: (0, utils_1.n)(order.howToCall),
        calldata: (0, utils_1.lc)(order.calldata),
        replacementPattern: (0, utils_1.lc)(order.replacementPattern),
        staticTarget: (0, utils_1.lc)(order.staticTarget),
        staticExtradata: (0, utils_1.lc)(order.staticExtradata),
        paymentToken: (0, utils_1.lc)(order.paymentToken),
        basePrice: (0, utils_1.s)(order.basePrice),
        extra: (0, utils_1.s)(order.extra),
        listingTime: (0, utils_1.n)(order.listingTime),
        expirationTime: (0, utils_1.n)(order.expirationTime),
        salt: (0, utils_1.s)(order.salt),
        v: (_a = order.v) !== null && _a !== void 0 ? _a : 0,
        r: (_b = order.r) !== null && _b !== void 0 ? _b : constants_1.HashZero,
        s: (_c = order.s) !== null && _c !== void 0 ? _c : constants_1.HashZero,
    };
};
//# sourceMappingURL=order.js.map