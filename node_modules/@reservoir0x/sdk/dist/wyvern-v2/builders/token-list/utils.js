"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMerkleProof = exports.generateMerkleTree = void 0;
const solidity_1 = require("@ethersproject/solidity");
const merkletreejs_1 = __importDefault(require("merkletreejs"));
const generateMerkleTree = (tokenIds) => {
    if (!tokenIds.length) {
        throw new Error("Could not generate merkle tree");
    }
    const hashFn = (buffer) => Buffer.from((0, solidity_1.keccak256)(["bytes"], [buffer]).slice(2), "hex");
    const leaves = tokenIds
        .sort()
        .map((tokenId) => Buffer.from((0, solidity_1.keccak256)(["uint256"], [tokenId]).slice(2), "hex"));
    return new merkletreejs_1.default(leaves, hashFn, { sortPairs: true });
};
exports.generateMerkleTree = generateMerkleTree;
const generateMerkleProof = (merkleTree, tokenId) => {
    const leaf = Buffer.from((0, solidity_1.keccak256)(["uint256"], [tokenId]).slice(2), "hex");
    const proof = merkleTree.getHexProof(leaf);
    if ("0x" + leaf.toString("hex") !== merkleTree.getHexRoot() &&
        proof.length === 0) {
        throw new Error("Could not generate merkle proof");
    }
    else {
        const numMerkleTreeLevels = merkleTree.getDepth();
        while (proof.length < numMerkleTreeLevels) {
            proof.push("0x" + "0".repeat(64));
        }
    }
    return proof;
};
exports.generateMerkleProof = generateMerkleProof;
//# sourceMappingURL=utils.js.map